"""Review mode - HTML generation for translation comparison."""

from pathlib import Path
from typing import List, Dict
from dataclasses import dataclass
from datetime import datetime

from .file_logger import get_logger


@dataclass
class TranslationSegment:
    """A segment with original and translated text."""
    index: int
    original: str
    translated: str
    has_issue: bool = False
    issue_type: str = None


class ReviewGenerator:
    """Generates HTML review files for translation comparison."""
    
    HTML_TEMPLATE = """<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TranslateX Review - {filename}</title>
    <style>
        * {{ box-sizing: border-box; }}
        body {{ 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0; padding: 20px; background: #f5f5f5;
        }}
        .header {{ 
            background: #2c3e50; color: white; padding: 20px; 
            border-radius: 8px; margin-bottom: 20px;
        }}
        .header h1 {{ margin: 0 0 10px 0; }}
        .stats {{ display: flex; gap: 20px; flex-wrap: wrap; }}
        .stat {{ background: rgba(255,255,255,0.1); padding: 10px 15px; border-radius: 4px; }}
        .segment {{ 
            background: white; border-radius: 8px; margin-bottom: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1); overflow: hidden;
        }}
        .segment.has-issue {{ border-left: 4px solid #e74c3c; }}
        .segment-header {{ 
            background: #ecf0f1; padding: 10px 15px; 
            font-size: 12px; color: #7f8c8d;
            display: flex; justify-content: space-between;
        }}
        .issue-badge {{ 
            background: #e74c3c; color: white; 
            padding: 2px 8px; border-radius: 4px; font-size: 11px;
        }}
        .content {{ display: flex; }}
        .original, .translated {{ flex: 1; padding: 15px; }}
        .original {{ background: #fafafa; border-right: 1px solid #eee; }}
        .label {{ 
            font-size: 11px; color: #95a5a6; 
            text-transform: uppercase; margin-bottom: 8px;
        }}
        .text {{ line-height: 1.6; white-space: pre-wrap; }}
        .footer {{ 
            text-align: center; padding: 20px; 
            color: #95a5a6; font-size: 12px;
        }}
    </style>
</head>
<body>
    <div class="header">
        <h1>Translation Review</h1>
        <div class="stats">
            <div class="stat">File: {filename}</div>
            <div class="stat">Total Segments: {total}</div>
            <div class="stat">Issues: {issues}</div>
            <div class="stat">Generated: {timestamp}</div>
        </div>
    </div>
    {segments_html}
    <div class="footer">
        Generated by TranslateX
    </div>
</body>
</html>"""
    
    SEGMENT_TEMPLATE = """
    <div class="segment {issue_class}">
        <div class="segment-header">
            <span>Segment {index}</span>
            {issue_badge}
        </div>
        <div class="content">
            <div class="original">
                <div class="label">Original</div>
                <div class="text">{original}</div>
            </div>
            <div class="translated">
                <div class="label">Translated</div>
                <div class="text">{translated}</div>
            </div>
        </div>
    </div>"""
    
    def __init__(self, output_file: str):
        """Initialize review generator.
        
        Args:
            output_file: Path for output HTML file
        """
        self.output_file = output_file
        self.segments: List[TranslationSegment] = []
    
    def add_segment(self, index: int, original: str, translated: str):
        """Add a translation segment for review.
        
        Args:
            index: Segment index
            original: Original text
            translated: Translated text
        """
        has_issue, issue_type = self._detect_issues(original, translated)
        
        self.segments.append(TranslationSegment(
            index=index,
            original=original,
            translated=translated,
            has_issue=has_issue,
            issue_type=issue_type
        ))
    
    def _detect_issues(self, original: str, translated: str) -> tuple[bool, str]:
        """Detect potential translation issues.
        
        Returns:
            Tuple of (has_issue, issue_type)
        """
        # Check for empty translation
        if not translated or not translated.strip():
            return True, "Empty translation"
        
        # Check for untranslated (same as original)
        if original.strip() == translated.strip():
            return True, "Possibly untranslated"
        
        # Check for significant length difference (>3x)
        orig_len = len(original.strip())
        trans_len = len(translated.strip())
        if orig_len > 0 and trans_len > 0:
            ratio = max(orig_len, trans_len) / min(orig_len, trans_len)
            if ratio > 3:
                return True, "Length mismatch"
        
        return False, None
    
    def generate(self, source_filename: str = "document") -> str:
        """Generate HTML review file.
        
        Args:
            source_filename: Name of source file for display
            
        Returns:
            Path to generated HTML file
        """
        logger = get_logger()
        
        # Build segments HTML
        segments_html = ""
        for seg in self.segments:
            issue_class = "has-issue" if seg.has_issue else ""
            issue_badge = f'<span class="issue-badge">{seg.issue_type}</span>' if seg.has_issue else ""
            
            segments_html += self.SEGMENT_TEMPLATE.format(
                index=seg.index + 1,
                issue_class=issue_class,
                issue_badge=issue_badge,
                original=self._escape_html(seg.original),
                translated=self._escape_html(seg.translated)
            )
        
        # Build full HTML
        issues_count = sum(1 for s in self.segments if s.has_issue)
        html = self.HTML_TEMPLATE.format(
            filename=source_filename,
            total=len(self.segments),
            issues=issues_count,
            timestamp=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            segments_html=segments_html
        )
        
        # Write file
        Path(self.output_file).parent.mkdir(parents=True, exist_ok=True)
        with open(self.output_file, "w", encoding="utf-8") as f:
            f.write(html)
        
        logger.info(f"Review file generated: {self.output_file}")
        return self.output_file
    
    def _escape_html(self, text: str) -> str:
        """Escape HTML special characters."""
        return (text
            .replace("&", "&amp;")
            .replace("<", "&lt;")
            .replace(">", "&gt;")
            .replace('"', "&quot;")
            .replace("'", "&#39;"))
    
    def get_issues(self) -> List[TranslationSegment]:
        """Get list of segments with issues."""
        return [s for s in self.segments if s.has_issue]
